% Created 2014-11-10 一 09:21
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\author{robin1001}
\date{\today}
\title{Notes}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.4.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle
\tableofcontents


\section{Shell program}
\label{sec-1}
Created by:robin1001 \textit{<2014-08-02 六>}

\begin{itemize}
\item -z, -r whether is empty, -s size 0
\item arr
\begin{verbatim}
arr = (1 2 3 4 5) #declare
${#arr[*]} | @    #length
unset arr[1]      #delete
${arr:i:j}        #slice, arr:start:len
\end{verbatim}
\item case
\begin{verbatim}
  case $1 in
	--* ) echo "--$1";;
	--*=* ) echo "--*=*";;
	--*:* ) echo "--*:*";;
	* ) break;;
esac
\end{verbatim}
\end{itemize}
\section{Emacs \& lisp}
\label{sec-2}
Created by:robin1001 \textit{<2014-08-04 一>}
\subsection{lisp}
\label{sec-2-1}
\begin{enumerate}
\item '( 1 2 3) \& (list 1 2 3)
\item progn--begin
\item 宏
\end{enumerate}
\begin{verbatim}
;;emacs lisp incr
(defmacro incr (var)
"Add one to the named variable."
 `(setq ,var (+ ,var 1)))

;;common lisp when
(defmacro when (condition &rest body)
  `(if (not ,condition) (prong ,@body)))
;;从宏定义的格式来看，定义宏中的形式体必须使用反引号“`”，表示对该形式体不求值，但是要对新宏的参数求值；
;;新宏的参数有两类，一个是新宏的形参，一个是新宏的形式体。
;;这两者的共同点就是都要通过逗号“,”来求值；
;;不同点有两处，一是形参用逗号直接求值，形式体则用逗号和@ 即 “,@” 去掉对形式体求值后所得到的表达式最外层列表的括号，将这个表达式嵌入到最外围列表的最后面；二是形参要做一系列处理，而形式体则直接求值嵌入，不做任何变化，这是因为这个形式体本来就是新宏的处理语句，定义宏只需要照搬即可，不需要也不应该做其他变化。
;;阅读宏定义代码或者自己去编写宏定义时，只要能牢牢把握住上面提到的差异，应该比较容易理解那些或简单、或复杂的宏代码了。

;;while
(defmacro while. (test &rest body)
  (let ((label (gensym)))
  `(tagbody
	,label
	(cond (,test ,@body (go ,label))))))
\end{verbatim}
\subsection{emacs keynotes}
\label{sec-2-2}
\begin{itemize}
\item (global-set-key "M-?" command)，设置全局快捷键
\item load-file：打开emacs lisp文件
\item load-path：emacs load启动，(append load-path ("/your/directory/here")))
\item require provied,像C的include的一样，在别的文件中引用内容
\item autoload，在调用时进行加载
\item message: (message "i am \%s \%d" "number" 1)
\item buffer-name: 当前buffer name, buffer-file-name
\item current-buffer other-buffer 当前buffer对象和最邻近使用的buffer
\item interactive：M-x函数名或快捷键可以激活
\item 快捷键 (global-set-key (kbd "S-<f12>") 'semantic-ia-fast-jump) or [S-f12] S-C-M
\item add-to-list
\item 函数名重映射 (defalias 'scroll-ahead 'scroll-up)
\end{itemize}
\subsection{emacs lisp grammer}
\label{sec-2-3}
\subsubsection{let}
\label{sec-2-3-1}
\begin{verbatim}
(defun square_add (a b)
  (let ((x (+ a b))
		(y (- a b)))
	(* x y)))
\end{verbatim}

\subsubsection{inner function}
\label{sec-2-3-2}
\begin{verbatim}
(defun factorial (n)
  (defun iter (product counter)
	(if (> counter n)
		product
	  (iter (* product counter) (+ counter 1))))
  (iter 1 1))
factorial
(factorial 10)
3628800
\end{verbatim}

\subsubsection{cond}
\label{sec-2-3-3}
\begin{verbatim}
(defun my_abs (x)
  (cond ((> x 0) x)
		((< x 0) (- x))
		(else 0)))
my_abs
(my_abs 2)
2
(my_abs -2)
2
\end{verbatim}
\subsection{plugin}
\label{sec-2-4}
\subsubsection{w3m}
\label{sec-2-4-1}
\begin{enumerate}
\item w3m-goto-url
\end{enumerate}
\subsubsection{emms}
\label{sec-2-4-2}
\begin{verbatim}
;;emms
(require 'emms-setup)
(emms-standard)
(emms-default-players)
\end{verbatim}

\subsection{important functions}
\label{sec-2-5}
\begin{enumerate}
\item isearch-forward(backward): search
\item help
\item other-window: next windows, back to recent edit window, (other-window -1)
\end{enumerate}

\subsection{Writing Emacs Extensions}
\label{sec-2-6}
\subsubsection{Customizing Emacs}
\label{sec-2-6-1}
\begin{enumerate}
\item lisp的特性，前缀s表达式，list,garbage collection
\item 定制快捷键
\end{enumerate}
\begin{verbatim}
(global-set-key "\M-?" command)
\end{verbatim}
\subsubsection{Simple New Commands}
\label{sec-2-6-2}
\begin{enumerate}
\item 切换窗口函数定义
\end{enumerate}
\begin{verbatim}
(defun other-window-backward ( )
"Select the previous window."
(interactive)
(other-window -1))
;;interaction with "p", wtih argument
(defun other-window-backward (n)
"Select Nth previous window."
(interactive "p")
(other-window (- n)))
;;
(defun other-window-backward (&optional n)
"Select Nth previous window."
(interactive "p")
(if n
(other-window (- n))
;ifn s non-nil
(other-window -1)))
;ifn snil
\end{verbatim}
\subsubsection{minor mode}
\label{sec-2-6-3}
\begin{verbatim}
(if evil-mode
	(message "yes")
  (message "no"))
\end{verbatim}
\section{The Design of The Unix Operating System}
\label{sec-3}
Created by:robin1001 \textit{<2014-08-28 四>}

\subsection{file system}
\label{sec-3-1}
\subsubsection{structure}
\label{sec-3-1-1}
\begin{center}
\begin{tabular}{llll}
boot block & super block & inode list & data blocks\\
定义函数模板\\
\end{tabular}
\end{center}
\section{Google C++ Style Guide}
\label{sec-4}
\begin{enumerate}
\item 函数超过10行时不要使用內联
\item -inl.h內联函数实现文件 | 定义函数模板
\item 输入：const型，输出参数：指针
\item 最好给纯接口类加上Interface后缀
\item 名称为foo$_{\text{的变量其访问函数为foo}}$()，而其修改器(mutator)则为set$_{\text{foo}}$()，访问器常在头文件中定义为内联函数。
\item 请按下面的规则次序来定义类：公共成员位于私有成员前；方法位于数据成员前(变量)等等。
\item scoped$_{\text{ptr}}$ | shared$_{\text{ptr}}$
\item 使用cpplint.py来检测风格错误
\item 类型转换(Casting),需要类型转换时请使用static$_{\text{cast}}$<>()
\item 类成员以下划线结束 int val\_;
\item 禁止使用异常
\end{enumerate}
\section{cpp}
\label{sec-5}
\subsection{stream stringstream, kaldi log}
\label{sec-5-1}
\subsection{<algorithm>}
\label{sec-5-2}
\subsubsection{非修改性质序列操作}
\label{sec-5-2-1}
\begin{itemize}
\item for$\backslash$$_{\text{each}}$: 通常和函数对象结合使用
\item find
\item count
\item equal
\item binary$\backslash$$_{\text{search}}$
\end{itemize}
\subsubsection{修改性质}
\label{sec-5-2-2}
\begin{itemize}
\item swap
\item reverse
\end{itemize}
\subsubsection{序列排序}
\label{sec-5-2-3}
\begin{itemize}
\item sort
\item stable$\backslash$$_{\text{sort}}$
\end{itemize}
\subsubsection{集合算法}
\label{sec-5-2-4}
\begin{itemize}
\item include
\item set$\backslash$$_{\text{union}}$
\item set$\backslash$$_{\text{intersection}}$
\item set$\backslash$$_{\text{difference}}$
\item rand$\backslash$$_{\text{shufle}}$
\end{itemize}
\subsubsection{堆操作}
\label{sec-5-2-5}
\begin{itemize}
\item make$\backslash$$_{\text{heap}}$
\item push$\backslash$$_{\text{heap}}$
\item pop$\backslash$$_{\text{head}}$
\item sort$\backslash$$_{\text{head}}$
\end{itemize}
\subsubsection{最大和最小}
\label{sec-5-2-6}
\begin{itemize}
\item min
\item max
\item min$\backslash$$_{\text{element}}$
\item max$\backslash$$_{\text{element}}$
\end{itemize}

\subsubsection{函数对象}
\label{sec-5-2-7}
\section{链接}
\label{sec-6}
链接库环境变量LD$\backslash$$_{\text{LIBRARY$\backslash$}}$$_{\text{PATH}}$
\section{Programming Language}
\label{sec-7}
\subsection{Course}
\label{sec-7-1}
\subsubsection{Section 1}
\label{sec-7-1-1}
\begin{enumerate}
\item ML Variable Binding and Expression
\label{sec-7-1-1-1}
\begin{enumerate}
\item comment (* *)
\item dynamic environment: Env
\item static enviroment: type, type check
\end{enumerate}
\item Rules for Expression
\label{sec-7-1-1-2}
\begin{enumerate}
\item syntax
\item type checking: static env
\item evaluation: dynamic env
\end{enumerate}
\item function
\label{sec-7-1-1-3}
\begin{verbatim}
fun cube(x: int) = x * x * x;
fun my_mul(x: int, y: int) = x * y;
\end{verbatim}
\item pair \& tuple
\label{sec-7-1-1-4}
\begin{verbatim}
val x = (2, 3);
val a = #1 x;
val b = #2 x;

fun swap(x: int * int) = (#2 x, #1 x);
\end{verbatim}
\item lists
\label{sec-7-1-1-5}
\begin{enumerate}
\item cons: 5::[1, 3, 5];
\item null: null e;
\item hd: car;
\item tl: cdr;
\end{enumerate}
\item let
\label{sec-7-1-1-6}
\begin{enumerate}
\item let \ldots{} in \ldots{} end
\item let \& scope
\end{enumerate}
\end{enumerate}
\subsection{python的函数式特性}
\label{sec-7-2}
\subsubsection{函数赋值}
\label{sec-7-2-1}
\begin{verbatim}
def square(n):
	return n*n
f = square
square(10)
\end{verbatim}
\subsubsection{lambda}
\label{sec-7-2-2}
\begin{verbatim}
square = lambda x: x*x;
square(10)
\end{verbatim}

\subsubsection{内置函数}
\label{sec-7-2-3}
\begin{verbatim}
map(square, [1, 2, 3])
reduce & filter
\end{verbatim}

\subsubsection{消除控制流}
\label{sec-7-2-4}
\begin{verbatim}
def func1(lst) :
  new_lst = []
  for n in lst :
	if odd(n) :
	  new_lst.append(square(n))
  return new_lst
可以改进为
def func2(lst) :
  return map(square, filter(odd, lst))
\end{verbatim}

\subsubsection{列表推导}
\label{sec-7-2-5}
\begin{verbatim}
[x for x in lis if x % 2 == 0]
\end{verbatim}

\subsubsection{闭包，计算函数的导数}
\label{sec-7-2-6}
\begin{verbatim}
def d(f) :
  def calc(x) :
	dx = 0.000001  # 表示无穷小的Δx
	return (f(x+dx) - f(x)) / dx  # 计算斜率。注意，此处引用了外层作用域的变量 f
  return calc  # 此处用函数作为返回值（也就是函数 f 的导数）

f = lambda x : x**2 + x + 1  # 先把二次函数用代码表达出来
f1 = d(f)  # 这个f1 就是 f 的一阶导数啦。注意，导数依然是个函数

f1(3)
\end{verbatim}
\section{Natural Language Processing}
\label{sec-8}
\subsection{Stanford}
\label{sec-8-1}
\subsubsection{参考书籍}
\label{sec-8-1-1}
\begin{itemize}
\item 朱拉夫斯基和曼宁《语音与语言处理》
\item 曼宁、舒策、拉哈万《信息检索导论》（2008）
\item 伯德、克莱因、洛普《使用Python进行自然语言处理》（2009）
\end{itemize}

\subsubsection{Basic Text Processing}
\label{sec-8-1-2}
\begin{enumerate}
\item Regular Expression
\label{sec-8-1-2-1}
\begin{itemize}
\item\relax []: [wW]oodchuck, [0-9], [a-z]
\item\relax [$^{\text{]}}$: not, [$\backslash$$^{\text{a}}$-z]
\item |: or
\item ?, *, +, .: times
\item \^{}, \&: start \& end
\end{itemize}
\item Word Tokenization
\label{sec-8-1-2-2}
\begin{enumerate}
\item shakespeare
\label{sec-8-1-2-2-1}
tr -sc 'a-zA-Z' '\n' < shakespeare.txt | sort | uniq -c | sort -n -r | less
\begin{itemize}
\item 将非单词替换为\n
\item 排序
\item 去重，并统计出现次数， uniq -c
\item 按出现次数排序，逆序输出
\item 如何统计每个单词的重复出现次数 tr -s "\t| " "\n" < word.txt | sort | uniq -c
\end{itemize}
\item 中文的分词
\label{sec-8-1-2-2-2}
\begin{itemize}
\item max-match
\end{itemize}
\end{enumerate}

\item Word Normaliztion \& Stemming
\label{sec-8-1-2-3}
\begin{itemize}
\item stem: Porter's algorithm
\item affix
\end{itemize}

\item Sentence Segmentation
\label{sec-8-1-2-4}
\begin{itemize}
\item ?, !: 通常没有歧义
\item .: 存在歧义，如Dr. 2014.12等。 解决方法，使用决策树判断.是否为句子结束
\end{itemize}
\end{enumerate}

\subsubsection{Edit Distance}
\label{sec-8-1-3}
\begin{enumerate}
\item Levenshtein distance: 替换代价为2,可以理解为先删除再插入
\item 算法: 动态规划, 通过回溯二维数组pre[i,j] = DOWN, LEFT, DIAG来记录回溯信息
\item 加权Edit Distance
\item confusion matrix, a容易被拼写为e;
\item 物理键盘的布局
\end{enumerate}
\includegraphics[width=.9\linewidth]{./nlp/confusion_matrix.png}
\includegraphics[width=.9\linewidth]{./nlp/weighted_edit.png}

\subsubsection{Language Modeling}
\label{sec-8-1-4}
\begin{itemize}
\item 机器翻译, Spell Correction, 语音识别
\item 一些工具 SRILM, Google N-Gram Release
\item a) Markov假设, b)取log避免下溢
\end{itemize}
\begin{enumerate}
\item Perplexity，如何评价一个语言模型
\label{sec-8-1-4-1}
\begin{itemize}
\item P[P(W)] = P(W)$^{\text{1}}$/N, 取对数即为1/NlogP(W)
\item Perplexity越小，better model
\end{itemize}
\item 数据稀疏问题，测试数据中出现训练集不存在的语法怎么办？
\label{sec-8-1-4-2}
\begin{itemize}
\item add-one, 假如为二元文法，V为所有bigram个数
\end{itemize}
\includegraphics[width=.9\linewidth]{./nlp/add_one.png}
\begin{itemize}
\item Good-Turing Estimate(参考数学之美)
\end{itemize}
基本思想是利用频率的类别信息对频率进行平滑。调整出现频率为c的n-gram频率
\end{enumerate}
\subsubsection{Spelling Correction}
\label{sec-8-1-5}
\begin{itemize}
\item w = arg max P(x|w)P(w), 前者为channel(error) model, 后者为language model, 可以使用unigram, bigram and on
\item P(x|w)中包含了transpose error，confusion matrix
\end{itemize}

\subsubsection{homework}
\label{sec-8-1-6}
% Emacs 24.4.1 (Org mode 8.2.10)
\end{document}
